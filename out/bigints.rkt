#lang racket
(require racket/block)

(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-char (lambda ()
  (let ([ out last-char])
    (block
      (next-char)
      out
    ))))

(define mread-int (lambda ()
  (if (eq? #\- last-char)
  (block
    (next-char) (- 0 (mread-int)))
    (letrec ([w (lambda (out)
      (if (eof-object? last-char)
        out
        (if (and last-char (>= (char->integer last-char) (char->integer #\0)) (<= (char->integer last-char) (char->integer #\9)))
          (let ([out (+ (* 10 out) (- (char->integer last-char) (char->integer #\0)))])
            (block
              (next-char)
              (w out)
          ))
        out
      )))]) (w 0)))))

(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(define max2 (lambda (a b) 
               (let ([ei (lambda (a b) 
                           '())])
               (if (> a b)
                 a
                 b))))
(define min2 (lambda (a b) 
               (let ([eh (lambda (a b) 
                           '())])
               (if (< a b)
                 a
                 b))))
(struct bigint ([bigint_chiffres #:mutable] [bigint_len #:mutable] [bigint_sign #:mutable]))
(define read_bigint (lambda (len) 
                      (let ([chiffres (array_init_withenv len (lambda (j) 
                                                                (lambda (len) 
                                                                  ((lambda (c) 
                                                                    (let ([ed (char->integer c)])
                                                                    (list len ed))) (mread-char)))) len)])
(let ([ef 0])
  (let ([eg (quotient (- len 1) 2)])
    (letrec ([ee (lambda (i len) 
                   (if (<= i eg)
                     (let ([tmp (vector-ref chiffres i)])
                       (block (vector-set! chiffres i (vector-ref chiffres (- (- len 1) i))) (block (vector-set! chiffres (- (- len 1) i) tmp) (ee (+ i 1) len))))
                     (bigint chiffres len #t)))])
    (ee ef len)))))))
(define print_bigint (lambda (a) 
                       (let ([ec (lambda (a) 
                                   (let ([ea 0])
                                     (let ([eb (- (bigint-bigint_len a) 1)])
                                       (letrec ([dz (lambda (i a) 
                                                      (if (<= i eb)
                                                        (block
                                                          (display (vector-ref (bigint-bigint_chiffres a) (- (- (bigint-bigint_len a) 1) i)))
                                                          (dz (+ i 1) a)
                                                          )
                                                        '()))])
                                       (dz ea a)))))])
  (if (not (bigint-bigint_sign a))
    (block
      (display (integer->char 45))
      (ec a)
      )
    (ec a)))))
(define bigint_eq (lambda (a b) 
                    ; Renvoie vrai si a = b 
                    (let ([dt (lambda (a b) 
                                '())])
                    (if (not (eq? (bigint-bigint_sign a) (bigint-bigint_sign b)))
                      #f
                      (let ([du (lambda (a b) 
                                  (dt a b))])
                      (if (not (eq? (bigint-bigint_len a) (bigint-bigint_len b)))
                        #f
                        (let ([dx 0])
                          (let ([dy (- (bigint-bigint_len a) 1)])
                            (letrec ([dv (lambda (i a b) 
                                           (if (<= i dy)
                                             (let ([dw (lambda (a b) 
                                                         (dv (+ i 1) a b))])
                                             (if (not (eq? (vector-ref (bigint-bigint_chiffres a) i) (vector-ref (bigint-bigint_chiffres b) i)))
                                               #f
                                               (dw a b)))
                                           #t))])
                          (dv dx a b))))))))))
(define bigint_gt (lambda (a b) 
                    ; Renvoie vrai si a > b 
                    (let ([dj (lambda (a b) 
                                '())])
                    (if (and (bigint-bigint_sign a) (not (bigint-bigint_sign b)))
                      #t
                      (let ([dk (lambda (a b) 
                                  (dj a b))])
                      (if (and (not (bigint-bigint_sign a)) (bigint-bigint_sign b))
                        #f
                        (let ([dl (lambda (a b) 
                                    #t)])
                        (if (> (bigint-bigint_len a) (bigint-bigint_len b))
                          (bigint-bigint_sign a)
                          (let ([dm (lambda (a b) 
                                      (dl a b))])
                          (if (< (bigint-bigint_len a) (bigint-bigint_len b))
                            (not (bigint-bigint_sign a))
                            (let ([dr 0])
                              (let ([ds (- (bigint-bigint_len a) 1)])
                                (letrec ([dn (lambda (i a b) 
                                               (if (<= i ds)
                                                 (let ([j (- (- (bigint-bigint_len a) 1) i)])
                                                   (let ([dp (lambda (j a b) 
                                                               (dn (+ i 1) a b))])
                                                   (if (> (vector-ref (bigint-bigint_chiffres a) j) (vector-ref (bigint-bigint_chiffres b) j))
                                                     (bigint-bigint_sign a)
                                                     (let ([dq (lambda (j a b) 
                                                                 (dp j a b))])
                                                     (if (< (vector-ref (bigint-bigint_chiffres a) j) (vector-ref (bigint-bigint_chiffres b) j))
                                                       (not (bigint-bigint_sign a))
                                                       (dq j a b))))))
                                  (dm a b)))])
                            (dn dr a b))))))))))))))
(define bigint_lt (lambda (a b) 
                    (not (bigint_gt a b))))
(define add_bigint_positif (lambda (a b) 
                             ; Une addition ou on en a rien a faire des signes 
                             (let ([len (+ (max2 (bigint-bigint_len a) (bigint-bigint_len b)) 1)])
                               (let ([retenue 0])
                                 (let ([chiffres (array_init_withenv len 
                                   (lambda (i) 
                                     (lambda (internal_env) (apply (lambda
                                      (retenue len a b) 
                                     (let ([tmp retenue])
                                       (let ([dg (lambda (tmp i retenue len a b) 
                                                   (let ([df (lambda (tmp i retenue len a b) 
                                                               (let ([retenue (quotient tmp 10)])
                                                                 (let ([de (remainder tmp 10)])
                                                                   (list (list retenue len a b) de))))])
                                                   (if (< i (bigint-bigint_len b))
                                                     (let ([tmp (+ tmp (vector-ref (bigint-bigint_chiffres b) i))])
                                                       (df tmp i retenue len a b))
                                                     (df tmp i retenue len a b))))])
                                     (if (< i (bigint-bigint_len a))
                                       (let ([tmp (+ tmp (vector-ref (bigint-bigint_chiffres a) i))])
                                         (dg tmp i retenue len a b))
                                       (dg tmp i retenue len a b))))) internal_env))) (list retenue len a b))])
                             (letrec ([di (lambda (retenue len a b) 
                                            (if (and (> len 0) (eq? (vector-ref chiffres (- len 1)) 0))
                                              (let ([len (- len 1)])
                                                (di retenue len a b))
                                              (bigint chiffres len #t)))])
                             (di retenue len a b)))))))
(define sub_bigint_positif (lambda (a b) 
                             ; Une soustraction ou on en a rien a faire des signes
                             ;Pré-requis : a > b
                             ;
                             (let ([len (bigint-bigint_len a)])
                               (let ([retenue 0])
                                 (let ([chiffres (array_init_withenv len 
                                   (lambda (i) 
                                     (lambda (internal_env) (apply (lambda
                                      (retenue len a b) 
                                     (let ([tmp (+ retenue (vector-ref (bigint-bigint_chiffres a) i))])
                                       (let ([db (lambda (tmp i retenue len a b) 
                                                   (let ([da (lambda (tmp i retenue len a b) 
                                                               (let ([cz tmp])
                                                                 (list (list retenue len a b) cz)))])
                                                   (if (< tmp 0)
                                                     (let ([tmp (+ tmp 10)])
                                                       (let ([retenue (- 1)])
                                                         (da tmp i retenue len a b)))
                                                     (let ([retenue 0])
                                                       (da tmp i retenue len a b)))))])
                                     (if (< i (bigint-bigint_len b))
                                       (let ([tmp (- tmp (vector-ref (bigint-bigint_chiffres b) i))])
                                         (db tmp i retenue len a b))
                                       (db tmp i retenue len a b))))) internal_env))) (list retenue len a b))])
                             (letrec ([dd (lambda (retenue len a b) 
                                            (if (and (> len 0) (eq? (vector-ref chiffres (- len 1)) 0))
                                              (let ([len (- len 1)])
                                                (dd retenue len a b))
                                              (bigint chiffres len #t)))])
                             (dd retenue len a b)))))))
(define neg_bigint (lambda (a) 
                     (bigint (bigint-bigint_chiffres a) (bigint-bigint_len a) (not (bigint-bigint_sign a)))))
(define add_bigint (lambda (a b) 
                     (let ([cu (lambda (a b) 
                                 '())])
                     (if (eq? (bigint-bigint_sign a) (bigint-bigint_sign b))
                       (let ([cv (lambda (a b) 
                                   (cu a b))])
                       (if (bigint-bigint_sign a)
                         (add_bigint_positif a b)
                         (neg_bigint (add_bigint_positif a b))))
                     (let ([cw (lambda (a b) 
                                 (cu a b))])
                     (if (bigint-bigint_sign a)
                       ; a positif, b negatif 
                       (let ([cx (lambda (a b) 
                                   (cw a b))])
                       (if (bigint_gt a (neg_bigint b))
                         (sub_bigint_positif a b)
                         (neg_bigint (sub_bigint_positif b a))))
                     ; a negatif, b positif 
                     (let ([cy (lambda (a b) 
                                 (cw a b))])
                     (if (bigint_gt (neg_bigint a) b)
                       (neg_bigint (sub_bigint_positif a b))
                       (sub_bigint_positif b a)))))))))
(define sub_bigint (lambda (a b) 
                     (add_bigint a (neg_bigint b))))
(define mul_bigint_cp (lambda (a b) 
                        ; Cet algorithm est quadratique.
                        ;C'est le même que celui qu'on enseigne aux enfants en CP.
                        ;D'ou le nom de la fonction. 
                        (let ([len (+ (+ (bigint-bigint_len a) (bigint-bigint_len b)) 1)])
                          (let ([chiffres (array_init_withenv len (lambda (k) 
                                                                    (lambda (internal_env) (apply (lambda
                                                                     (len a b) 
                                                                    (let ([cj 0])
                                                                    (list (list len a b) cj))) internal_env))) (list len a b))])
                          (let ([cs 0])
                            (let ([ct (- (bigint-bigint_len a) 1)])
                              (letrec ([co (lambda (i len a b) 
                                             (if (<= i ct)
                                               (let ([retenue 0])
                                                 (let ([cq 0])
                                                   (let ([cr (- (bigint-bigint_len b) 1)])
                                                     (letrec ([cp (lambda (j retenue len a b) 
                                                                    (if (<= j cr)
                                                                    (block (vector-set! chiffres (+ i j) (+ (vector-ref chiffres (+ i j)) (+ retenue (* (vector-ref (bigint-bigint_chiffres b) j) (vector-ref (bigint-bigint_chiffres a) i))))) 
                                                                    (let ([retenue (quotient (vector-ref chiffres (+ i j)) 10)])
                                                                    (block (vector-set! chiffres (+ i j) (remainder (vector-ref chiffres (+ i j)) 10)) (cp (+ j 1) retenue len a b))))
                                                                    (block (vector-set! chiffres (+ i (bigint-bigint_len b)) (+ (vector-ref chiffres (+ i (bigint-bigint_len b))) retenue)) (co (+ i 1) len a b))))])
                                                     (cp cq retenue len a b)))))
                                             (block (vector-set! chiffres (+ (bigint-bigint_len a) (bigint-bigint_len b)) (quotient (vector-ref chiffres (- (+ (bigint-bigint_len a) (bigint-bigint_len b)) 1)) 10)) (block (vector-set! chiffres (- (+ (bigint-bigint_len a) (bigint-bigint_len b)) 1) (remainder (vector-ref chiffres (- (+ (bigint-bigint_len a) (bigint-bigint_len b)) 1)) 10)) 
                                             (let ([cm 0])
                                               (let ([cn 2])
                                                 (letrec ([ck (lambda (l len a b) 
                                                                (if (<= l cn)
                                                                  (let ([cl 
                                                                    (lambda (len a b) 
                                                                    (ck (+ l 1) len a b))])
                                                                  (if (and (not (eq? len 0)) (eq? (vector-ref chiffres (- len 1)) 0))
                                                                    (let ([len (- len 1)])
                                                                    (cl len a b))
                                                                    (cl len a b)))
                                                                (bigint chiffres len (eq? (bigint-bigint_sign a) (bigint-bigint_sign b)))))])
                                               (ck cm len a b))))))))])
                        (co cs len a b))))))))
(define bigint_premiers_chiffres (lambda (a i) 
                                   (let ([len (min2 i (bigint-bigint_len a))])
                                     (letrec ([ci (lambda (len a i) 
                                                    (if (and (not (eq? len 0)) (eq? (vector-ref (bigint-bigint_chiffres a) (- len 1)) 0))
                                                      (let ([len (- len 1)])
                                                        (ci len a i))
                                                      (bigint (bigint-bigint_chiffres a) len (bigint-bigint_sign a))))])
                                     (ci len a i)))))
(define bigint_shift (lambda (a i) 
                       (let ([e (+ (bigint-bigint_len a) i)])
                         (let ([chiffres (array_init_withenv e (lambda (k) 
                                                                 (lambda (internal_env) (apply (lambda
                                                                  (e a i) 
                                                                 (let ([cg 
                                                                   (lambda (k e a i) 
                                                                    (lambda (cf) 
                                                                    (list (list e a i) cf)))])
                                                                 (if (>= k i)
                                                                   (let ([cf (vector-ref (bigint-bigint_chiffres a) (- k i))])
                                                                    (list (list e a i) cf))
                                                                   (let ([cf 0])
                                                                    (list (list e a i) cf))))) internal_env))) (list e a i))])
  (bigint chiffres (+ (bigint-bigint_len a) i) (bigint-bigint_sign a))))))
(define mul_bigint (lambda (aa bb) 
                     (let ([cc (lambda (aa bb) 
                                 ; Algorithme de Karatsuba 
                                 (let ([split (quotient (min2 (bigint-bigint_len aa) (bigint-bigint_len bb)) 2)])
                                   (let ([a (bigint_shift aa (- split))])
                                     (let ([b (bigint_premiers_chiffres aa split)])
                                       (let ([c (bigint_shift bb (- split))])
                                         (let ([d (bigint_premiers_chiffres bb split)])
                                           (let ([amoinsb (sub_bigint a b)])
                                             (let ([cmoinsd (sub_bigint c d)])
                                               (let ([ac (mul_bigint a c)])
                                                 (let ([bd (mul_bigint b d)])
                                                   (let ([amoinsbcmoinsd (mul_bigint amoinsb cmoinsd)])
                                                     (let ([acdec (bigint_shift ac (* 2 split))])
                                                       (add_bigint (add_bigint acdec bd) (bigint_shift (sub_bigint (add_bigint ac bd) amoinsbcmoinsd) split))))))))))))))])
                     (if (eq? (bigint-bigint_len aa) 0)
                       aa
                       (let ([cd (lambda (aa bb) 
                                   (cc aa bb))])
                       (if (eq? (bigint-bigint_len bb) 0)
                         bb
                         (let ([ce (lambda (aa bb) 
                                     (cd aa bb))])
                         (if (or (< (bigint-bigint_len aa) 3) (< (bigint-bigint_len bb) 3))
                           (mul_bigint_cp aa bb)
                           (ce aa bb)))))))))
(define log10 (lambda (a) 
                (let ([out_ 1])
                  (letrec ([cb (lambda (out_ a) 
                                 (if (>= a 10)
                                   (let ([a (quotient a 10)])
                                     (let ([out_ (+ out_ 1)])
                                       (cb out_ a)))
                                   out_))])
                  (cb out_ a)))))
(define bigint_of_int (lambda (i) 
                        (let ([size (log10 i)])
                          (let ([bz (lambda (size i) 
                                      (let ([t_ (array_init_withenv size 
                                        (lambda (j) 
                                          (lambda (internal_env) (apply (lambda
                                           (size i) 
                                          (let ([bv 0])
                                            (list (list size i) bv))) internal_env))) (list size i))])
                                      (let ([bx 0])
                                        (let ([by (- size 1)])
                                          (letrec ([bw (lambda (k size i) 
                                                         (if (<= k by)
                                                           (block (vector-set! t_ k (remainder i 10)) 
                                                           (let ([i (quotient i 10)])
                                                             (bw (+ k 1) size i)))
                                                           (bigint t_ size #t)))])
                                          (bw bx size i))))))])
  (if (eq? i 0)
    (let ([size 0])
      (bz size i))
    (bz size i))))))
(define fact_bigint (lambda (a) 
                      (let ([one (bigint_of_int 1)])
                        (let ([out_ one])
                          (letrec ([bu (lambda (out_ one a) 
                                         (if (not (bigint_eq a one))
                                           (let ([out_ (mul_bigint a out_)])
                                             (let ([a (sub_bigint a one)])
                                               (bu out_ one a)))
                                           out_))])
                          (bu out_ one a))))))
(define sum_chiffres_bigint (lambda (a) 
                              (let ([out_ 0])
                                (let ([br 0])
                                  (let ([bs (- (bigint-bigint_len a) 1)])
                                    (letrec ([bq (lambda (i out_ a) 
                                                   (if (<= i bs)
                                                     (let ([out_ (+ out_ (vector-ref (bigint-bigint_chiffres a) i))])
                                                       (bq (+ i 1) out_ a))
                                                     out_))])
                                    (bq br out_ a)))))))
(define euler20 (lambda () 
                  (let ([a (bigint_of_int 15)])
                    ; normalement c'est 100 
                    (let ([a (fact_bigint a)])
                      (sum_chiffres_bigint a)))))
(define bigint_exp (lambda (a b) 
                     (let ([bo (lambda (a b) 
                                 '())])
                     (if (eq? b 1)
                       a
                       (let ([bp (lambda (a b) 
                                   (bo a b))])
                       (if (eq? (remainder b 2) 0)
                         (bigint_exp (mul_bigint a a) (quotient b 2))
                         (mul_bigint a (bigint_exp a (- b 1)))))))))
(define bigint_exp_10chiffres (lambda (a b) 
                                (let ([a (bigint_premiers_chiffres a 10)])
                                  (let ([bm (lambda (a b) 
                                              '())])
                                  (if (eq? b 1)
                                    a
                                    (let ([bn (lambda (a b) 
                                                (bm a b))])
                                    (if (eq? (remainder b 2) 0)
                                      (bigint_exp_10chiffres (mul_bigint a a) (quotient b 2))
                                      (mul_bigint a (bigint_exp_10chiffres a (- b 1))))))))))
(define euler48 (lambda () 
                  (let ([sum (bigint_of_int 0)])
                    (let ([bk 1])
                      (let ([bl 100])
                        (letrec ([bj (lambda (i sum) 
                                       (if (<= i bl)
                                         ; 1000 normalement 
                                         (let ([ib (bigint_of_int i)])
                                           (let ([ibeib (bigint_exp_10chiffres ib i)])
                                             (let ([sum (add_bigint sum ibeib)])
                                               (let ([sum (bigint_premiers_chiffres sum 10)])
                                                 (bj (+ i 1) sum)))))
                                         (block
                                           (display "euler 48 = ")
                                           (print_bigint sum)
                                           (display "\n")
                                           )))])
                        (bj bk sum)))))))
(define euler16 (lambda () 
                  (let ([a (bigint_of_int 2)])
                    (let ([a (bigint_exp a 100)])
                      ; 1000 normalement 
                      (sum_chiffres_bigint a)))))
(define euler25 (lambda () 
                  (let ([i 2])
                    (let ([a (bigint_of_int 1)])
                      (let ([b (bigint_of_int 1)])
                        (letrec ([bi (lambda (b a i) 
                                       (if (< (bigint-bigint_len b) 100)
                                         ; 1000 normalement 
                                         (let ([c (add_bigint a b)])
                                           (let ([a b])
                                             (let ([b c])
                                               (let ([i (+ i 1)])
                                                 (bi b a i)))))
                                         i))])
                        (bi b a i)))))))
(define euler29 (lambda () 
                  (let ([maxA 5])
                    (let ([maxB 5])
                      (let ([f (+ maxA 1)])
                        (let ([a_bigint (array_init_withenv f (lambda (j) 
                                                                (lambda (internal_env) (apply (lambda
                                                                 (f maxB maxA) 
                                                                (let ([o (bigint_of_int (* j j))])
                                                                  (list (list f maxB maxA) o))) internal_env))) (list f maxB maxA))])
                        (let ([g (+ maxA 1)])
                          (let ([a0_bigint (array_init_withenv g (lambda (j2) 
                                                                   (lambda (internal_env) (apply (lambda
                                                                    (g f maxB maxA) 
                                                                   (let ([p (bigint_of_int j2)])
                                                                    (list (list g f maxB maxA) p))) internal_env))) (list g f maxB maxA))])
                          (let ([h (+ maxA 1)])
                            (let ([b (array_init_withenv h (lambda (k) 
                                                             (lambda (internal_env) (apply (lambda
                                                              (h g f maxB maxA) 
                                                             (let ([q 2])
                                                               (list (list h g f maxB maxA) q))) internal_env))) (list h g f maxB maxA))])
                            (let ([n 0])
                              (let ([found #t])
                                (letrec ([s (lambda (found n h g f maxB maxA) 
                                              (if found
                                                (let ([min_ (vector-ref a0_bigint 0)])
                                                  (let ([found #f])
                                                    (let ([bf 2])
                                                      (let ([bg maxA])
                                                        (letrec ([z (lambda (i min_ found n h g f maxB maxA) 
                                                                    (if (<= i bg)
                                                                    (let ([ba 
                                                                    (lambda (min_ found n h g f maxB maxA) 
                                                                    (z (+ i 1) min_ found n h g f maxB maxA))])
                                                                    (if (<= (vector-ref b i) maxB)
                                                                    (let ([bc 
                                                                    (lambda (min_ found n h g f maxB maxA) 
                                                                    (ba min_ found n h g f maxB maxA))])
                                                                    (if found
                                                                    (let ([be 
                                                                    (lambda (min_ found n h g f maxB maxA) 
                                                                    (bc min_ found n h g f maxB maxA))])
                                                                    (if (bigint_lt (vector-ref a_bigint i) min_)
                                                                    (let ([min_ (vector-ref a_bigint i)])
                                                                    (be min_ found n h g f maxB maxA))
                                                                    (be min_ found n h g f maxB maxA)))
                                                                    (let ([min_ (vector-ref a_bigint i)])
                                                                    (let ([found #t])
                                                                    (bc min_ found n h g f maxB maxA)))))
                                                                    (ba min_ found n h g f maxB maxA)))
                                                        (let ([u (lambda (min_ found n h g f maxB maxA) 
                                                                   (s found n h g f maxB maxA))])
                                                        (if found
                                                          (let ([n (+ n 1)])
                                                            (let ([x 2])
                                                              (let ([y maxA])
                                                                (letrec ([v 
                                                                  (lambda (l min_ found n h g f maxB maxA) 
                                                                    (if (<= l y)
                                                                    (let ([w 
                                                                    (lambda (min_ found n h g f maxB maxA) 
                                                                    (v (+ l 1) min_ found n h g f maxB maxA))])
                                                                    (if (and (bigint_eq (vector-ref a_bigint l) min_) (<= (vector-ref b l) maxB))
                                                                    (block (vector-set! b l (+ (vector-ref b l) 1)) (block (vector-set! a_bigint l (mul_bigint (vector-ref a_bigint l) (vector-ref a0_bigint l))) (w min_ found n h g f maxB maxA)))
                                                                    (w min_ found n h g f maxB maxA)))
                                                                    (u min_ found n h g f maxB maxA)))])
                                                              (v x min_ found n h g f maxB maxA)))))
                                                      (u min_ found n h g f maxB maxA)))))])
                                  (z bf min_ found n h g f maxB maxA))))))
                        n))])
                  (s found n h g f maxB maxA))))))))))))))
(define main (block
               (display (euler29 ))
               (display "\n")
               (let ([sum (read_bigint 50)])
                 (let ([el 2])
                   (let ([em 100])
                     (letrec ([ek (lambda (i sum) 
                                    (if (<= i em)
                                      (block (mread-blank) (let ([tmp (read_bigint 50)])
                                                             (let ([sum (add_bigint sum tmp)])
                                                               (ek (+ i 1) sum))) )
                                      (block
                                        (display "euler13 = ")
                                        (print_bigint sum)
                                        (display "\n")
                                        (display "euler25 = ")
                                        (display (euler25 ))
                                        (display "\n")
                                        (display "euler16 = ")
                                        (display (euler16 ))
                                        (display "\n")
                                        (euler48 )
                                        (display "euler20 = ")
                                        (display (euler20 ))
                                        (display "\n")
                                        (let ([a (bigint_of_int 999999)])
                                          (let ([b (bigint_of_int 9951263)])
                                            (block
                                              (print_bigint a)
                                              (display ">>1=")
                                              (print_bigint (bigint_shift a (- 1)))
                                              (display "\n")
                                              (print_bigint a)
                                              (display "*")
                                              (print_bigint b)
                                              (display "=")
                                              (print_bigint (mul_bigint a b))
                                              (display "\n")
                                              (print_bigint a)
                                              (display "*")
                                              (print_bigint b)
                                              (display "=")
                                              (print_bigint (mul_bigint_cp a b))
                                              (display "\n")
                                              (print_bigint a)
                                              (display "+")
                                              (print_bigint b)
                                              (display "=")
                                              (print_bigint (add_bigint a b))
                                              (display "\n")
                                              (print_bigint b)
                                              (display "-")
                                              (print_bigint a)
                                              (display "=")
                                              (print_bigint (sub_bigint b a))
                                              (display "\n")
                                              (print_bigint a)
                                              (display "-")
                                              (print_bigint b)
                                              (display "=")
                                              (print_bigint (sub_bigint a b))
                                              (display "\n")
                                              (print_bigint a)
                                              (display ">")
                                              (print_bigint b)
                                              (display "=")
                                              (let ([m (bigint_gt a b)])
                                                (let ([ej (lambda (m b a sum) 
                                                            (display "\n"))])
                                                (if m
                                                  (block
                                                    (display "True")
                                                    (ej m b a sum)
                                                    )
                                                  (block
                                                    (display "False")
                                                    (ej m b a sum)
                                                    ))))
                                            )))
                                      )))])
                   (ek el sum)))))
))

